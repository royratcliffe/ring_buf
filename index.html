<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ring_buf: Ring Buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ring_buf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Ring Buffers </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> What are ring buffers[^1] and why are they useful? The “ring” in “ring buffer” refers to fixed-size memory space under continuous cyclic reuse. The structure is a FIFO[^2] container, ideal for stream buffering where produced events are processed in the order received by a consumer. Exemplar applications include asynchronous communication scenarios, e.g. interrupt service routines in embedded systems.</p>
<p>Zephyr includes a promising <a href="https://docs.zephyrproject.org/latest/kernel/data_structures/ring_buffers.html">component</a> by Intel. Zephyr is an excellent real-time operating system for resource-constrained embedded devices. Nordic Semiconductor’s <a href="https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop">nRF Connect</a> development kit runs on <a href="https://github.com/zephyrproject-rtos/zephyr">Zephyr</a>. This article describes a refactored version of the Zephyr ring buffer implementation.</p>
<p>The goal here is to provide:</p>
<ul>
<li>operating system agnostic C99 portability;</li>
<li>highly efficient constant time complexity;</li>
<li>an adjusted two-layer ring buffer implementation that allows for passive iteration; and</li>
<li>easy destructive circularity where a write operation consumes the oldest read when the buffer fills up.</li>
</ul>
<p>The implementation language is C99 since the target platform for this kind of collection structure is a memory-limited embedded device of some sort. The C99 code needs access to basic types: fast unsigned and signed integers.</p>
<p><img src="ring-buf.svg" alt="Ring buffer class diagram" style="pointer-events: none;" class="inline"/></p>
<p>Find the complete implementation on <a href="https://github.com/royratcliffe/ring_buf">GitHub</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Claiming and Acknowledging</h1>
<ol type="1">
<li>Claim space,</li>
<li>access space,</li>
<li>acknowledge space.</li>
</ol>
<p>This is the three-phase basic ring buffer access pattern. Space claims work on spans of <em>contiguous</em> space. Take special note of the important italics. Buffer claims access only contiguous buffer space, never to discontiguous space.</p>
<p><em>Putting</em> writes to a ring buffer. <em>Get</em> operations read from a ring buffer. One put operation starts with a claim. A successful claim expands the “put zone” by the requested number of bytes. Acknowledging the same number of bytes advances the put zone. Notice that the claim cannot span across the end of the buffer space. Buffer size less the put zone’s head <em>clamps</em> the claim size. It <b>cannot</b> exceed the remaining contiguous space.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">/*!</div>
<div class="line"> * \brief Claims space for putting data into a ring buffer.</div>
<div class="line"> * \details Claims contiguous space. Advances the &quot;put&quot; head.</div>
<div class="line"> */</div>
<div class="line">ring_buf_size_t ring_buf_put_claim(struct ring_buf *buf, void **space,</div>
<div class="line">                                   ring_buf_size_t size) {</div>
<div class="line">  ring_buf_ptrdiff_t base = buf-&gt;put.base;</div>
<div class="line">  ring_buf_size_t head = ring_buf_zone_head(&amp;buf-&gt;put);</div>
<div class="line">  if (head &gt;= buf-&gt;size) {</div>
<div class="line">    base += buf-&gt;size;</div>
<div class="line">    head -= buf-&gt;size;</div>
<div class="line">  }</div>
<div class="line">  ring_buf_clamp(&amp;size, buf-&gt;size - head);</div>
<div class="line">  ring_buf_clamp(&amp;size, ring_buf_free_space(buf));</div>
<div class="line">  if (space)</div>
<div class="line">    *space = (uint8_t *)buf-&gt;space + (buf-&gt;put.head - base);</div>
<div class="line">  buf-&gt;put.head += size;</div>
<div class="line">  return size;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Acknowledgement works thus:</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">/*!</div>
<div class="line"> * \brief Acknowledges space claimed for putting data into a ring buffer.</div>
<div class="line"> * \param buf Ring buffer address.</div>
<div class="line"> * \param size Number of bytes to acknowledge.</div>
<div class="line"> * \retval 0 on successful put.</div>
<div class="line"> * \retval -EINVAL if \c size exceeds previously claimed aggregate space.</div>
<div class="line"> */</div>
<div class="line">int ring_buf_put_ack(struct ring_buf *buf, ring_buf_size_t size) {</div>
<div class="line">  ring_buf_size_t claim = ring_buf_zone_claim(&amp;buf-&gt;put);</div>
<div class="line">  if (size &gt; claim)</div>
<div class="line">    return -EINVAL;</div>
<div class="line">  buf-&gt;put.head = (buf-&gt;put.tail += size);</div>
<div class="line">  if (ring_buf_zone_tail(&amp;buf-&gt;put) &gt;= buf-&gt;size)</div>
<div class="line">    buf-&gt;put.base += buf-&gt;size;</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Get operations do their work analogously. Getting spans the get zone, the used buffer space rather than the free buffer space.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Putting and Getting</h1>
<p>The put operation puts as much data in the ring buffer as possible. Its answer is the number of bytes successfully buffered. The result may be zero bytes or less than the number requested. Implementation below.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">/*!</div>
<div class="line"> * \brief Puts non-contiguous bytes into the ring buffer.</div>
<div class="line"> * \details The return value may be less than the given size if the buffer runs</div>
<div class="line"> * out of free space.</div>
<div class="line"> * \note Does \e not automatically acknowledge the space.</div>
<div class="line"> * \param buf Ring buffer.</div>
<div class="line"> * \param data Address of bytes to put.</div>
<div class="line"> * \param size Number of bytes to put.</div>
<div class="line"> * \returns Buffer space to acknowledge in bytes.</div>
<div class="line"> */</div>
<div class="line">ring_buf_size_t ring_buf_put(struct ring_buf *buf, const void *data,</div>
<div class="line">                             ring_buf_size_t size) {</div>
<div class="line">  ring_buf_size_t ack = 0U, claim;</div>
<div class="line">  do {</div>
<div class="line">    void *space;</div>
<div class="line">    claim = ring_buf_put_claim(buf, &amp;space, size);</div>
<div class="line">    (void)memcpy(space, data, claim);</div>
<div class="line">    *(const uint8_t **)&amp;data += claim;</div>
<div class="line">    ack += claim;</div>
<div class="line">  } while (claim &amp;&amp; (size -= claim));</div>
<div class="line">  return ack;</div>
<div class="line">}</div>
</div><!-- fragment --><p>What does this mean in practice? You can put partials. This behaviour exists by design. It is not a mistake. Use a guarded claim to ensure full item buffering. Claim first and then <em>only</em> acknowledge the put size if the buffer can successfully claim sufficient space.</p>
<p>Putting <em>part</em> of something may not always be required. The buffer may contain discrete chunks of fixed-size data: integers or floats, for instance. In such cases, the ring buffer must claim and acknowledge all or none and never less than all.</p>
<p>Two alternative solutions exist: (i) check the free space first; or (ii) attempt to put and only acknowledge a complete copy. The first solution runs faster at first blush. The second solution requires a little more work but fails quickly assuming the buffer holds <em>only</em> chunks of data of equal size <em>and</em> the capacity of the buffer corresponds to a multiple of that size.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Putting all, getting all</h2>
<p>Acknowledgement only fails if the size of the acknowledgement exceeds the size of the previous claim. The “putter” can safely ignore the possible erroneous result if the acknowledgement matches the previous claim, or when acknowledging zero since zero is always less than or equal to any previous claim.</p>
<div class="fragment"><div class="line"> c</div>
<div class="line">int ring_buf_put_all(struct ring_buf *buf, const void *data,</div>
<div class="line">                     ring_buf_size_t size) {</div>
<div class="line">  ring_buf_size_t ack = ring_buf_put(buf, data, size);</div>
<div class="line">  int err = ack &lt; size ? -EMSGSIZE : 0;</div>
<div class="line">  if (err &lt; 0)</div>
<div class="line">    ack = 0U;</div>
<div class="line">  (void)ring_buf_put_ack(buf, ack);</div>
<div class="line">  return err;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This approach comes with a disadvantage whenever the claim fails to meet the requested item size. A partial buffer copy could arise. The partial put or get operation would correctly disclaim the copied data. A performance hit occurs nevertheless: copying unnecessarily when the buffer cannot hold the data when putting the incoming bytes, or has insufficient data if outgoing. This <em>only</em> assumes that the buffer items have variable lengths or that the buffer space is <em>not</em> a multiple of the item size. Partial copies can never occur for fixed-size items in a harmonically-sized[^3] buffer space.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Usage</h1>
<p>How does passive iteration work? Take an example. Assume that a ring buffer contains only floating-point numbers. Repeated claims will iterate through the <em>get</em> zone; a final $0$-acknowledgement will restore the zone, amounting to a sneaky peek at the buffer’s entire contents. See the excerpt below; it sums up the floats.</p>
<div class="fragment"><div class="line">c</div>
<div class="line"> float sum = 0.0F;</div>
<div class="line"> void *space;</div>
<div class="line"> while ((ring_buf_get_claim(&amp;buf, &amp;space, sizeof(float))))</div>
<div class="line">   sum += *(float *)space;</div>
<div class="line"> ring_buf_get_ack(&amp;buf, 0U);</div>
</div><!-- fragment --><p>This makes some assumptions:</p>
<ol type="1">
<li>It assumes that the buffer only contains floats. Hence the claims return only the size of a float or $0$. A non-zero return value therefore indicates a float. The <code>while</code> condition uses double brackets to highlight the implied <code>!= 0</code> test.</li>
<li>No memory alignment concerns arise.</li>
</ol>
<p>Also, note that the iteration does <b>not</b> copy the floats. It accesses the contents without copying them. Zero-copy translates to greater efficiency for embedded devices, especially useful during interrupt service handlers and similar time-constrained contexts.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Conclusions</h1>
<p>The implementation makes use of signed integer magic. It aims to minimise pointer arithmetic. Head and tail indices apply <em>base</em>-relative addressing. A buffer space’s actual head index $h'=h-b$ where $h$ is the head of a zone and $b$ is its base. The same goes for a zone’s tail.</p>
<p>Some surprises arise. Partial putting seems wrong at first. Some scenarios exist where this feature presents a desirable asset. Draining UART or other peripheral buffers come to mind. The UART service handlers want to put as much data in the ring buffer as possible and acknowledge the partial transfer so that their downstream handlers can pick up the contents as quickly as possible while unloading the peripheral registers as much as possible for the upstream incoming hardware to remain as ready as possible for the next cycle and its tranche of data.</p>
<p>The implementation differs from Zephyr, albeit inspired by Intel’s contribution. The simple putter or getter must <b>always</b> acknowledge the claimed space. Put and get operations follow the claim-acknowledge protocol whether non-contiguous or contiguous. The same protocol applies to both.</p>
<p>Item-based putting and getting lives in its own separate module—another difference. The included <a href="https://github.com/royratcliffe/ring_buf/blob/main/ring_buf_item.h">item access interface</a> stores only the size. It does <em>not</em> include other information such as type.</p>
<p>[^1]: also known as circular buffers</p>
<p>[^2]: first in, first out</p>
<p>[^3]: meaning that the entire buffer space divides evenly by the item size without remainder </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
