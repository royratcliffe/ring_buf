<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ring_buf: Ring Buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ring_buf
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Ring Buffers </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> What are ring buffers[^1] and why are they useful? The “ring” in “ring buffer” refers to fixed-size memory space under continuous cyclic reuse. The structure is a FIFO[^2] container, ideal for stream buffering where produced events are processed in the order received by a consumer. Exemplar applications include asynchronous communication scenarios, e.g. interrupt service routines in embedded systems.</p>
<p>Zephyr includes a promising <a href="https://docs.zephyrproject.org/latest/kernel/data_structures/ring_buffers.html">component</a> by Intel. Zephyr is an excellent real-time operating system for resource-constrained embedded devices. Nordic Semiconductor’s <a href="https://www.nordicsemi.com/Products/Development-tools/nRF-Connect-for-Desktop">nRF Connect</a> development kit runs on <a href="https://github.com/zephyrproject-rtos/zephyr">Zephyr</a>. This article describes a refactored version of the Zephyr ring buffer implementation.</p>
<p>The goal here is to provide:</p>
<ul>
<li>operating system agnostic C99 portability;</li>
<li>highly efficient constant time complexity;</li>
<li>an adjusted two-layer ring buffer implementation that allows for passive iteration; and</li>
<li>easy destructive circularity where a write operation consumes the oldest read when the buffer fills up.</li>
</ul>
<p>The implementation language is C99 since the target platform for this kind of collection structure is a memory-limited embedded device of some sort. The C99 code needs access to basic types: fast unsigned and signed integers.</p>
<div class="image">
<object type="image/svg+xml" data="ring-buf.svg" style="pointer-events: none;"></object>
<div class="caption">
Ring buffer class diagram</div></div>
    <p>Find the complete implementation on <a href="https://github.com/royratcliffe/ring_buf">GitHub</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Claiming and Acknowledging</h1>
<ol type="1">
<li>Claim space,</li>
<li>access space,</li>
<li>acknowledge space.</li>
</ol>
<p>This is the three-phase basic ring buffer access pattern. Space claims work on spans of <em>contiguous</em> space. Take special note of the important italics. Buffer claims access only contiguous buffer space, never to discontiguous space.</p>
<p><em>Putting</em> writes to a ring buffer. <em>Get</em> operations read from a ring buffer. One put operation starts with a claim. A successful claim expands the “put zone” by the requested number of bytes. Acknowledging the same number of bytes advances the put zone. Notice that the claim cannot span across the end of the buffer space. Buffer size less the put zone’s head <em>clamps</em> the claim size. It <b>cannot</b> exceed the remaining contiguous space.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> <a class="code hl_function" href="group__ring__buf__contiguous.html#gafedeb6dc879b63c70a7a24420f2c16fb">ring_buf_put_claim</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structring__buf.html">ring_buf</a> *buf, <span class="keywordtype">void</span> **space,</div>
<div class="line">                                   <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> size) {</div>
<div class="line">  <a class="code hl_typedef" href="ring__buf_8h.html#ad5122caf8d567667ef0fa4341bc4ac36">ring_buf_ptrdiff_t</a> base = buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>.<a class="code hl_variable" href="structring__buf__zone.html#aaf6d4b8f4e22bb094079dbceefd09b4b">base</a>;</div>
<div class="line">  <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> head = <a class="code hl_function" href="ring__buf_8c.html#af05c4ffbb9361f71c9c73f41631d622c">ring_buf_zone_head</a>(&amp;buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>);</div>
<div class="line">  <span class="keywordflow">if</span> (head &gt;= buf-&gt;<a class="code hl_variable" href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">size</a>) {</div>
<div class="line">    base += buf-&gt;<a class="code hl_variable" href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">size</a>;</div>
<div class="line">    head -= buf-&gt;<a class="code hl_variable" href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">size</a>;</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_function" href="ring__buf_8c.html#a4c6cf6a0946f58fee8bba932bd97e3b8">ring_buf_clamp</a>(&amp;size, buf-&gt;<a class="code hl_variable" href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">size</a> - head);</div>
<div class="line">  <a class="code hl_function" href="ring__buf_8c.html#a4c6cf6a0946f58fee8bba932bd97e3b8">ring_buf_clamp</a>(&amp;size, <a class="code hl_function" href="group__ring__buf.html#gadc53d953dc769a8f8ad172275ebfa6d4">ring_buf_free_space</a>(buf));</div>
<div class="line">  <span class="keywordflow">if</span> (space)</div>
<div class="line">    *space = (uint8_t *)buf-&gt;<a class="code hl_variable" href="structring__buf.html#a700577c362b1e92aa5cfbfd184962805">space</a> + (buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>.<a class="code hl_variable" href="structring__buf__zone.html#a955c3995c67bc0b59ea024788f885c82">head</a> - base);</div>
<div class="line">  buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>.<a class="code hl_variable" href="structring__buf__zone.html#a955c3995c67bc0b59ea024788f885c82">head</a> += size;</div>
<div class="line">  <span class="keywordflow">return</span> size;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ring__buf__contiguous_html_gafedeb6dc879b63c70a7a24420f2c16fb"><div class="ttname"><a href="group__ring__buf__contiguous.html#gafedeb6dc879b63c70a7a24420f2c16fb">ring_buf_put_claim</a></div><div class="ttdeci">ring_buf_size_t ring_buf_put_claim(struct ring_buf *buf, void **space, ring_buf_size_t size)</div><div class="ttdoc">Claims space for putting data into a ring buffer.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00101">ring_buf.c:101</a></div></div>
<div class="ttc" id="agroup__ring__buf_html_gadc53d953dc769a8f8ad172275ebfa6d4"><div class="ttname"><a href="group__ring__buf.html#gadc53d953dc769a8f8ad172275ebfa6d4">ring_buf_free_space</a></div><div class="ttdeci">static ring_buf_size_t ring_buf_free_space(const struct ring_buf *buf)</div><div class="ttdoc">Calculates free space in the ring buffer.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00184">ring_buf.h:184</a></div></div>
<div class="ttc" id="aring__buf_8c_html_a4c6cf6a0946f58fee8bba932bd97e3b8"><div class="ttname"><a href="ring__buf_8c.html#a4c6cf6a0946f58fee8bba932bd97e3b8">ring_buf_clamp</a></div><div class="ttdeci">static void ring_buf_clamp(ring_buf_size_t *clamp, ring_buf_size_t limit)</div><div class="ttdoc">Clamp a value to a specified limit.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00045">ring_buf.c:45</a></div></div>
<div class="ttc" id="aring__buf_8c_html_af05c4ffbb9361f71c9c73f41631d622c"><div class="ttname"><a href="ring__buf_8c.html#af05c4ffbb9361f71c9c73f41631d622c">ring_buf_zone_head</a></div><div class="ttdeci">static ring_buf_size_t ring_buf_zone_head(const struct ring_buf_zone *zone)</div><div class="ttdoc">Head index of a zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00059">ring_buf.c:59</a></div></div>
<div class="ttc" id="aring__buf_8h_html_a6726adf0857732cea1a7b84bc3685b94"><div class="ttname"><a href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a></div><div class="ttdeci">size_t ring_buf_size_t</div><div class="ttdoc">Ring buffer size type.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00064">ring_buf.h:64</a></div></div>
<div class="ttc" id="aring__buf_8h_html_ad5122caf8d567667ef0fa4341bc4ac36"><div class="ttname"><a href="ring__buf_8h.html#ad5122caf8d567667ef0fa4341bc4ac36">ring_buf_ptrdiff_t</a></div><div class="ttdeci">ptrdiff_t ring_buf_ptrdiff_t</div><div class="ttdoc">Ring buffer pointer difference type.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00058">ring_buf.h:58</a></div></div>
<div class="ttc" id="astructring__buf__zone_html_a955c3995c67bc0b59ea024788f885c82"><div class="ttname"><a href="structring__buf__zone.html#a955c3995c67bc0b59ea024788f885c82">ring_buf_zone::head</a></div><div class="ttdeci">ring_buf_ptrdiff_t head</div><div class="ttdoc">Head index of the zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00105">ring_buf.h:105</a></div></div>
<div class="ttc" id="astructring__buf__zone_html_aaf6d4b8f4e22bb094079dbceefd09b4b"><div class="ttname"><a href="structring__buf__zone.html#aaf6d4b8f4e22bb094079dbceefd09b4b">ring_buf_zone::base</a></div><div class="ttdeci">ring_buf_ptrdiff_t base</div><div class="ttdoc">Base index of the zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00099">ring_buf.h:99</a></div></div>
<div class="ttc" id="astructring__buf_html"><div class="ttname"><a href="structring__buf.html">ring_buf</a></div><div class="ttdoc">Ring buffer instance.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00129">ring_buf.h:129</a></div></div>
<div class="ttc" id="astructring__buf_html_a21863cd78e19929620191cbe96ec2935"><div class="ttname"><a href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">ring_buf::size</a></div><div class="ttdeci">ring_buf_size_t size</div><div class="ttdoc">Size of the ring buffer.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00140">ring_buf.h:140</a></div></div>
<div class="ttc" id="astructring__buf_html_a700577c362b1e92aa5cfbfd184962805"><div class="ttname"><a href="structring__buf.html#a700577c362b1e92aa5cfbfd184962805">ring_buf::space</a></div><div class="ttdeci">void * space</div><div class="ttdoc">Pointer to the buffer's data space.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00134">ring_buf.h:134</a></div></div>
<div class="ttc" id="astructring__buf_html_af6fd6be8e31f908881b2eacffe4d6a96"><div class="ttname"><a href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">ring_buf::put</a></div><div class="ttdeci">struct ring_buf_zone put</div><div class="ttdoc">Put zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00146">ring_buf.h:146</a></div></div>
</div><!-- fragment --><p>Acknowledgement works thus:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="group__ring__buf__contiguous.html#ga0951ca395862822d953742b6b34dc7ba">ring_buf_put_ack</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structring__buf.html">ring_buf</a> *buf, <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> size) {</div>
<div class="line">  <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> claim = <a class="code hl_function" href="ring__buf_8c.html#a902e811a6600d43a3b1c526e25168b62">ring_buf_zone_claim</a>(&amp;buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>);</div>
<div class="line">  <span class="keywordflow">if</span> (size &gt; claim)</div>
<div class="line">    <span class="keywordflow">return</span> -EINVAL;</div>
<div class="line">  buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>.<a class="code hl_variable" href="structring__buf__zone.html#a955c3995c67bc0b59ea024788f885c82">head</a> = (buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>.<a class="code hl_variable" href="structring__buf__zone.html#a45f8057e950d9e515b5c394f1c8ee95a">tail</a> += size);</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_function" href="ring__buf_8c.html#a618239a52aaab4d1c04eb11ace89cb69">ring_buf_zone_tail</a>(&amp;buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>) &gt;= buf-&gt;<a class="code hl_variable" href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">size</a>)</div>
<div class="line">    buf-&gt;<a class="code hl_variable" href="structring__buf.html#af6fd6be8e31f908881b2eacffe4d6a96">put</a>.<a class="code hl_variable" href="structring__buf__zone.html#aaf6d4b8f4e22bb094079dbceefd09b4b">base</a> += buf-&gt;<a class="code hl_variable" href="structring__buf.html#a21863cd78e19929620191cbe96ec2935">size</a>;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ring__buf__contiguous_html_ga0951ca395862822d953742b6b34dc7ba"><div class="ttname"><a href="group__ring__buf__contiguous.html#ga0951ca395862822d953742b6b34dc7ba">ring_buf_put_ack</a></div><div class="ttdeci">int ring_buf_put_ack(struct ring_buf *buf, ring_buf_size_t size)</div><div class="ttdoc">Acknowledges space claimed for putting data into a ring buffer.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00117">ring_buf.c:117</a></div></div>
<div class="ttc" id="aring__buf_8c_html_a618239a52aaab4d1c04eb11ace89cb69"><div class="ttname"><a href="ring__buf_8c.html#a618239a52aaab4d1c04eb11ace89cb69">ring_buf_zone_tail</a></div><div class="ttdeci">static ring_buf_size_t ring_buf_zone_tail(const struct ring_buf_zone *zone)</div><div class="ttdoc">Tail index of a zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00069">ring_buf.c:69</a></div></div>
<div class="ttc" id="aring__buf_8c_html_a902e811a6600d43a3b1c526e25168b62"><div class="ttname"><a href="ring__buf_8c.html#a902e811a6600d43a3b1c526e25168b62">ring_buf_zone_claim</a></div><div class="ttdeci">static ring_buf_size_t ring_buf_zone_claim(const struct ring_buf_zone *zone)</div><div class="ttdoc">Claim size of a zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00080">ring_buf.c:80</a></div></div>
<div class="ttc" id="astructring__buf__zone_html_a45f8057e950d9e515b5c394f1c8ee95a"><div class="ttname"><a href="structring__buf__zone.html#a45f8057e950d9e515b5c394f1c8ee95a">ring_buf_zone::tail</a></div><div class="ttdeci">ring_buf_ptrdiff_t tail</div><div class="ttdoc">Tail index of the zone.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00111">ring_buf.h:111</a></div></div>
</div><!-- fragment --><p>Get operations do their work analogously. Getting spans the get zone, the used buffer space rather than the free buffer space.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Putting and Getting</h1>
<p>The put operation puts as much data in the ring buffer as possible. Its answer is the number of bytes successfully buffered. The result may be zero bytes or less than the number requested. Implementation below.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> <a class="code hl_function" href="group__ring__buf__discontiguous.html#gadc1d3c9eb87dc575c54b85b548b821f7">ring_buf_put</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structring__buf.html">ring_buf</a> *buf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data,</div>
<div class="line">                             <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> size) {</div>
<div class="line">  <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> ack = 0U, claim;</div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="keywordtype">void</span> *space;</div>
<div class="line">    claim = <a class="code hl_function" href="group__ring__buf__contiguous.html#gafedeb6dc879b63c70a7a24420f2c16fb">ring_buf_put_claim</a>(buf, &amp;space, size);</div>
<div class="line">    (void)memcpy(space, data, claim);</div>
<div class="line">    *(<span class="keyword">const</span> uint8_t **)&amp;data += claim;</div>
<div class="line">    ack += claim;</div>
<div class="line">  } <span class="keywordflow">while</span> (claim &amp;&amp; (size -= claim));</div>
<div class="line">  <span class="keywordflow">return</span> ack;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ring__buf__discontiguous_html_gadc1d3c9eb87dc575c54b85b548b821f7"><div class="ttname"><a href="group__ring__buf__discontiguous.html#gadc1d3c9eb87dc575c54b85b548b821f7">ring_buf_put</a></div><div class="ttdeci">ring_buf_size_t ring_buf_put(struct ring_buf *buf, const void *data, ring_buf_size_t size)</div><div class="ttdoc">Puts non-contiguous bytes into the ring buffer.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00153">ring_buf.c:153</a></div></div>
</div><!-- fragment --><p>What does this mean in practice? You can put partials. This behaviour exists by design. It is not a mistake. Use a guarded claim to ensure full item buffering. Claim first and then <em>only</em> acknowledge the put size if the buffer can successfully claim sufficient space.</p>
<p>Putting <em>part</em> of something may not always be required. The buffer may contain discrete chunks of fixed-size data: integers or floats, for instance. In such cases, the ring buffer must claim and acknowledge all or none and never less than all.</p>
<p>Two alternative solutions exist: (i) check the free space first; or (ii) attempt to put and only acknowledge a complete copy. The first solution runs faster at first blush. The second solution requires a little more work but fails quickly assuming the buffer holds <em>only</em> chunks of data of equal size <em>and</em> the capacity of the buffer corresponds to a multiple of that size.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Putting all, getting all</h2>
<p>Acknowledgement only fails if the size of the acknowledgement exceeds the size of the previous claim. The “putter” can safely ignore the possible erroneous result if the acknowledgement matches the previous claim, or when acknowledging zero since zero is always less than or equal to any previous claim.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="group__ring__buf__discontiguous.html#gab23d79ab595c3c620ff6ebbb578736d1">ring_buf_put_all</a>(<span class="keyword">struct</span> <a class="code hl_struct" href="structring__buf.html">ring_buf</a> *buf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data,</div>
<div class="line">                     <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> size) {</div>
<div class="line">  <a class="code hl_typedef" href="ring__buf_8h.html#a6726adf0857732cea1a7b84bc3685b94">ring_buf_size_t</a> ack = <a class="code hl_function" href="group__ring__buf__discontiguous.html#gadc1d3c9eb87dc575c54b85b548b821f7">ring_buf_put</a>(buf, data, size);</div>
<div class="line">  <span class="keywordtype">int</span> err = ack &lt; size ? -<a class="code hl_define" href="ring__buf_8h.html#ae37becfaa095a9df5c5c788bce5aa06f">EMSGSIZE</a> : 0;</div>
<div class="line">  <span class="keywordflow">if</span> (err &lt; 0)</div>
<div class="line">    ack = 0U;</div>
<div class="line">  (void)<a class="code hl_function" href="group__ring__buf__contiguous.html#ga0951ca395862822d953742b6b34dc7ba">ring_buf_put_ack</a>(buf, ack);</div>
<div class="line">  <span class="keywordflow">return</span> err;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__ring__buf__discontiguous_html_gab23d79ab595c3c620ff6ebbb578736d1"><div class="ttname"><a href="group__ring__buf__discontiguous.html#gab23d79ab595c3c620ff6ebbb578736d1">ring_buf_put_all</a></div><div class="ttdeci">int ring_buf_put_all(struct ring_buf *buf, const void *data, ring_buf_size_t size)</div><div class="ttdoc">Puts all or none.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00181">ring_buf.c:181</a></div></div>
<div class="ttc" id="aring__buf_8h_html_ae37becfaa095a9df5c5c788bce5aa06f"><div class="ttname"><a href="ring__buf_8h.html#ae37becfaa095a9df5c5c788bce5aa06f">EMSGSIZE</a></div><div class="ttdeci">#define EMSGSIZE</div><div class="ttdoc">Message size error code.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8h_source.html#l00051">ring_buf.h:51</a></div></div>
</div><!-- fragment --><p>This approach comes with a disadvantage whenever the claim fails to meet the requested item size. A partial buffer copy could arise. The partial put or get operation would correctly disclaim the copied data. A performance hit occurs nevertheless: copying unnecessarily when the buffer cannot hold the data when putting the incoming bytes, or has insufficient data if outgoing. This <em>only</em> assumes that the buffer items have variable lengths or that the buffer space is <em>not</em> a multiple of the item size. Partial copies can never occur for fixed-size items in a harmonically-sized[^3] buffer space.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Usage</h1>
<p>How does passive iteration work? Take an example. Assume that a ring buffer contains only floating-point numbers. Repeated claims will iterate through the <em>get</em> zone; a final $0$-acknowledgement will restore the zone, amounting to a sneaky peek at the buffer’s entire contents. See the excerpt below; it sums up the floats.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> sum = 0.0F;</div>
<div class="line"><span class="keywordtype">void</span> *space;</div>
<div class="line"><span class="keywordflow">while</span> ((<a class="code hl_function" href="group__ring__buf__contiguous.html#gab44ba225bffe812d591a8868688dd9f7">ring_buf_get_claim</a>(&amp;buf, &amp;space, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>))))</div>
<div class="line">  sum += *(<span class="keywordtype">float</span> *)space;</div>
<div class="line"><a class="code hl_function" href="group__ring__buf__contiguous.html#ga0b6c867e0994f58f536d15d98ced47a2">ring_buf_get_ack</a>(&amp;buf, 0U);</div>
<div class="ttc" id="agroup__ring__buf__contiguous_html_ga0b6c867e0994f58f536d15d98ced47a2"><div class="ttname"><a href="group__ring__buf__contiguous.html#ga0b6c867e0994f58f536d15d98ced47a2">ring_buf_get_ack</a></div><div class="ttdeci">int ring_buf_get_ack(struct ring_buf *buf, ring_buf_size_t size)</div><div class="ttdoc">Acknowledges space claimed for getting data from a ring buffer.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00143">ring_buf.c:143</a></div></div>
<div class="ttc" id="agroup__ring__buf__contiguous_html_gab44ba225bffe812d591a8868688dd9f7"><div class="ttname"><a href="group__ring__buf__contiguous.html#gab44ba225bffe812d591a8868688dd9f7">ring_buf_get_claim</a></div><div class="ttdeci">ring_buf_size_t ring_buf_get_claim(struct ring_buf *buf, void **space, ring_buf_size_t size)</div><div class="ttdoc">Claims contiguous space for getting.</div><div class="ttdef"><b>Definition</b> <a href="ring__buf_8c_source.html#l00127">ring_buf.c:127</a></div></div>
</div><!-- fragment --><p>This makes some assumptions:</p>
<ol type="1">
<li>It assumes that the buffer only contains floats. Hence the claims return only the size of a float or $0$. A non-zero return value therefore indicates a float. The <code>while</code> condition uses double brackets to highlight the implied <code>!= 0</code> test.</li>
<li>No memory alignment concerns arise.</li>
</ol>
<p>Also, note that the iteration does <b>not</b> copy the floats. It accesses the contents without copying them. Zero-copy translates to greater efficiency for embedded devices, especially useful during interrupt service handlers and similar time-constrained contexts.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Conclusions</h1>
<p>The implementation makes use of signed integer magic. It aims to minimise pointer arithmetic. Head and tail indices apply <em>base</em>-relative addressing. A buffer space’s actual head index $h'=h-b$ where $h$ is the head of a zone and $b$ is its base. The same goes for a zone’s tail.</p>
<p>Some surprises arise. Partial putting seems wrong at first. Some scenarios exist where this feature presents a desirable asset. Draining UART or other peripheral buffers come to mind. The UART service handlers want to put as much data in the ring buffer as possible and acknowledge the partial transfer so that their downstream handlers can pick up the contents as quickly as possible while unloading the peripheral registers as much as possible for the upstream incoming hardware to remain as ready as possible for the next cycle and its tranche of data.</p>
<p>The implementation differs from Zephyr, albeit inspired by Intel’s contribution. The simple putter or getter must <b>always</b> acknowledge the claimed space. Put and get operations follow the claim-acknowledge protocol whether non-contiguous or contiguous. The same protocol applies to both.</p>
<p>Item-based putting and getting lives in its own separate module—another difference. The included <a href="https://github.com/royratcliffe/ring_buf/blob/main/ring_buf_item.h">item access interface</a> stores only the size. It does <em>not</em> include other information such as type.</p>
<p>[^1]: also known as circular buffers</p>
<p>[^2]: first in, first out</p>
<p>[^3]: meaning that the entire buffer space divides evenly by the item size without remainder </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
